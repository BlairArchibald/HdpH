module Main where

import Data.ByteString (ByteString)
import qualified Data.ByteString as BS (length, pack, foldl')
import Data.Functor ((<$>))
import Data.Serialize (Serialize, encode, decode)
import Network.BSD (getHostName)
import System.Environment (getArgs)
import System.Posix.Process (getProcessID)
import System.Random (getStdGen, randoms)

import Control.Parallel.HdpH.MPI.Allgather
       (withMPI, Size(..), Rank(..), allgatherByteString)


randomBS :: IO ByteString
randomBS = do
  g <- getStdGen
  let n:bytes = randoms g
  let bs = BS.pack (take (fromIntegral n) bytes)
  return bs

sumBS :: ByteString -> Integer
sumBS bs = BS.foldl' (\ x y -> x + toInteger y) 0 bs

-- Generalizes 'allgatherByteString' to arbitrary serialisable values.
allgather :: (Serialize a) => a -> IO [a]
allgather = fmap (map decode') . allgatherByteString . encode
  where
    decode' bs = case decode bs of
                   Left e  -> error $ "Main.allgather: " ++ e
                   Right x -> x


-- Test distribution of randomly generated bytestrings (up to 255 bytes long);
-- to be run in 'withMPI' block.
test1 :: IO [ByteString]
test1 = do
  bs0 <- randomBS
  bss <- allgatherByteString bs0
  return (bs0:bss)

-- Test distribution of short ID strings;
-- to be run in 'withMPI' block.
test2 :: IO [String]
test2 = do
  pid  <- show <$> getProcessID
  name <- getHostName
  let s0 = name ++ "." ++ pid
  ss  <- allgather s0
  return (s0:ss)


-- Post-process the results of 'test1'.
pp1 :: Size -> Rank -> [ByteString] -> IO ()
pp1 _        _        []        = return ()
pp1 (Size n) (Rank r) (bs0:bss) =
  putStrLn $ show r ++ "/" ++ show n ++
             " n="    ++ show (length bss) ++
             " len0=" ++ show (BS.length bs0) ++
             " sum0=" ++ show (sumBS bs0) ++
             " lens=" ++ show (map BS.length bss) ++
             " sums=" ++ show (map sumBS bss)

-- Post-process the results of 'test2'.
pp2 :: Size -> Rank -> [String] -> IO ()
pp2 _        _        []        = return ()
pp2 (Size n) (Rank r) (s0:ss) = do
  if r == 0
    then do
      putStrLn $ show r ++ "/" ++ show n ++
                 " " ++ show s0 ++ " " ++ show ss
      putStrLn $ show r ++ "/" ++ show n ++
                 " n="     ++ show (length ss) ++
                 " total=" ++ show (sum (map length ss)) ++
                 " lens="  ++ show (zip [(0 :: Int) ..] $ map length ss)
    else return ()

parseArgs :: [String] -> (Bool, Bool)
parseArgs []      = (True,  True)
parseArgs ("1":_) = (True,  False)
parseArgs ("2":_) = (False, True)
parseArgs _       = (False, False)

main :: IO ()
main = do
  args <- getArgs
  let (t1, t2) = parseArgs args
  (size, rank, out1, out2) <- withMPI $ \ size rank -> do
    out1 <- if t1 then test1 else return []
    out2 <- if t2 then test2 else return []
    return (size, rank, out1, out2)
  if t1 then pp1 size rank out1 else return ()
  if t2 then pp2 size rank out2 else return ()
