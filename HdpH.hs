-- HdpH programming interface
--
-- Visibility: public
-- Author: Patrick Maier <P.Maier@hw.ac.uk>
-- Created: 10 Jul 2011
--
-----------------------------------------------------------------------------

{-# LANGUAGE GeneralizedNewtypeDeriving #-}  -- for 'GIVar'
{-# LANGUAGE TypeSynonymInstances #-}        -- for 'Par'
{-# LANGUAGE FlexibleInstances #-}           -- for 'Par'
{-# LANGUAGE TemplateHaskell #-}             -- for 'mkClosure', etc.

module HdpH
  ( -- * runtime system
    RTS,           -- * -> *; instances: Functor, Monad
    runRTS_,       -- :: RTSConf -> RTS () -> IO ()
    isMainRTS,     -- :: RTS Bool
    shutdownRTS,   -- :: RTS ()
    liftIO,        -- :: IO a -> RTS a

    -- * runtime system configuration
    module HdpH.Conf,

    -- * Par monad
    Par,        -- * -> *; instances: Functor, Monad
    runPar,     -- :: Par a -> RTS a
    runParIO_,  -- :: RTSConf -> Par () -> IO ()
    runParIO,   -- :: RTSConf -> Par a -> IO (Maybe a)

    -- * operations in the Par monad
    done,       -- :: Par a
    myNode,     -- :: Par NodeId
    allNodes,   -- :: Par [NodeId]
    io,         -- :: IO a -> Par a
    eval,       -- :: a -> Par a
    force,      -- :: (NFData a) => a -> Par a
    fork,       -- :: Par () -> Par ()
    spark,      -- :: Closure (Par ()) -> Par ()
    pushTo,     -- :: Closure (Par ()) -> NodeId -> Par ()
    new,        -- :: Par (IVar a)
    put,        -- :: IVar a -> a -> Par ()
    get,        -- :: IVar a -> Par a
    poll,       -- :: IVar a -> Par (Maybe a)
    probe,      -- :: IVar a -> Par Bool
    glob,       -- :: IVar (Closure a) -> Par (GIVar (Closure a))
    rput,       -- :: GIVar (Closure a) -> Closure a -> Par ()

    -- * locations
    NodeId,  -- instances: Eq, Ord, Show, NFData, Serialize

    -- * local and global IVars
    IVar,    -- * -> *; instances: none
    GIVar,   -- * -> *; instances: Eq, Ord, Show, NFData, Serialize
    at,      -- :: GIVar a -> NodeId

    -- * explicit Closures
    module HdpH.Closure,

    -- * Static declaration for internal Closures in HdpH and HdpH.Closure
    declareStatic   -- :: StaticDecl
  ) where

import Prelude hiding (error)
import Control.Concurrent.MVar (newEmptyMVar, putMVar, takeMVar)
import Control.DeepSeq (NFData, deepseq)
import Control.Monad (when)
import Data.Functor ((<$>))
import Data.IORef (newIORef, readIORef, writeIORef)
import Data.Monoid (mconcat)
import Data.Serialize (Serialize)

import HdpH.Conf                            -- re-export whole module
import HdpH.Closure hiding (declareStatic)  -- re-export almost whole module
import qualified HdpH.Closure (declareStatic)
import qualified HdpH.Internal.Comm as Comm
       (myNode, allNodes, isMain, shutdown)
import qualified HdpH.Internal.IVar as IVar (IVar, GIVar)
import HdpH.Internal.IVar
       (hostGIVar, newIVar, putIVar, getIVar, pollIVar, probeIVar,
        globIVar, putGIVar)
import HdpH.Internal.Location (NodeId, dbgStaticTab)
import HdpH.Internal.Scheduler
       (RTS, liftThreadM, liftSparkM, liftCommM, liftIO,
        schedulerID, mkThread, execThread, sendPUSH)
import qualified HdpH.Internal.Scheduler as Scheduler (run_)
import HdpH.Internal.Sparkpool (putSpark)
import HdpH.Internal.Threadpool (putThread, putThreads)
import HdpH.Internal.Type.Par (ParM(Par), unPar, Thread(Atom))


-----------------------------------------------------------------------------
-- Static declaration

declareStatic :: StaticDecl
declareStatic = mconcat
  [HdpH.Closure.declareStatic,
   declare $(static 'rput_abs)]


-----------------------------------------------------------------------------
-- abstract IVars and GIVars

newtype IVar a = IVar (IVar.IVar RTS a)

newtype GIVar a = GIVar (IVar.GIVar RTS a)
                  deriving (Eq, Ord, NFData, Serialize)

-- Show instance (mainly for debugging)
instance Show (GIVar a) where
  showsPrec _ (GIVar gv) = showString "GIVar:" . shows gv

at :: GIVar a -> NodeId
at (GIVar gv) = hostGIVar gv


-----------------------------------------------------------------------------
-- abstract runtime system

-- Module HdpH exports a monad 'RTS' which encapsulates all Haskell-level
-- runtime system functionality. It offers operations to run RTS computations
-- (which will mostly be generated by 'runPar', but can also be lifted IO
-- computations), performing parallel machine setup and initialisation
-- behind the scenes. Every RTS computation must issue the action 'shutdownRTS'
-- on exactly one node before terminating.

-- Eliminate the RTS monad down to IO by running the given 'action';
-- aspects of the RTS's behaviour are controlled by the respective parameters 
-- in the 'conf' argument.
runRTS_ :: RTSConf -> RTS () -> IO ()
runRTS_ = Scheduler.run_

-- Return True iff this node is the root (or main) node.
isMainRTS :: RTS Bool
isMainRTS = liftCommM Comm.isMain

-- Initiate RTS shutdown (which will print stats, given the right debug level).
shutdownRTS :: RTS ()
shutdownRTS = liftCommM Comm.shutdown

-- Print global Static table to stdout, one entry a line.
printStaticTable :: RTS ()
printStaticTable =
  liftIO $ mapM_ putStrLn $
    "Static Table:" : map ("  " ++) showStaticTable


-----------------------------------------------------------------------------
-- Par monad, based on ideas from
--   [1] Claessen "A Poor Man's Concurrency Monad", JFP 9(3), 1999.
--   [2] Marlow et al. "A monad for deterministic parallelism". Haskell 2011.

-- TODO: The use of the Par monad is rather close to Bill Harrison's
--       'resumption monads' [3]. Try to rewrite the definitions here
--       and in HdpH.Internal.Type.Par to make Par a resumption monad.
--       [3] Harrison "The Essence of Multitasking". AMAST 2006.
-- ANSWER: Would actually need to make Par into a reactive resumption monad,
--         which is not very different from the current continuation style.

-- 'Par' is a type synonym hiding the RTS parameter; a newtype would be
-- nicer but the resulting wrapping and unwrapping destroys readability
-- (if it is possible at all).
type Par = ParM RTS

instance Functor Par where
    fmap f m = Par $ \ c -> unPar m (c . f)

-- The Monad instance is where we differ from Control.Monad.Cont,
-- the difference being the use of strict application ($!).
-- TODO: Test whether strictness is still necessary; it was prior to v0.3.0 
--       to ensure thread actions were actually executed; differences
--       in the action type may render it unnecessary.
-- ANSWER: Strictness is not necessary now, but it does increase performance
--         marginally.
instance Monad Par where
    return a = Par $ \ c -> c $! a
    m >>= k  = Par $ \ c -> unPar m $ \ a -> unPar (k $! a) c


-- Eliminate the 'Par' monad layer by converting the given 'Par' action 'p'
-- into an RTS action (which should then be executed on one node of the
-- parallel machine).
runPar :: Par a -> RTS a
runPar p = do -- create an empty MVar expecting the result of action 'p'
              res <- liftIO $ newEmptyMVar

              -- fork 'p', combined with a write to above MVar;
              -- note that the starter thread (ie the 'fork') runs outwith
              -- any scheduler (and terminates quickly); the forked action
              -- (ie. 'p >>= ...') runs in a scheduler, however.
              execThread $ mkThread $ fork (p >>= io . putMVar res)

              -- block waiting for result
              liftIO $ takeMVar res


-- Convenience: combines 'runPar' and 'runRTS_' (including shutdown).
-- TODO: There appear to be races during shutdown which can cause the
--       system to hang.
runParIO_ :: RTSConf -> Par () -> IO ()
runParIO_ conf p = runRTS_ conf $ do isMain <- isMainRTS
                                     when isMain $ do
                                       -- print Static table
                                       when (dbgStaticTab <= debugLvl conf)
                                         printStaticTable
                                       runPar p
                                       shutdownRTS


-- Convenience: variant of 'runParIO_' which does return a result
-- (on the main node; all other nodes return Nothing).
runParIO :: RTSConf -> Par a -> IO (Maybe a)
runParIO conf p = do res <- newIORef Nothing
                     runParIO_ conf (p >>= io . writeIORef res . Just)
                     readIORef res


-----------------------------------------------------------------------------
-- operations in the Par monad

-- TODO: Implement 'yield :: Par ()'; semantics like Control.Concurrent.yield

-- thread termination
done :: Par a
done = Par $ \ _c -> Atom (return Nothing)

-- lifting RTS into the Par monad (really a monadic map); don't export
atom :: RTS a -> Par a
atom m = Par $ \ c -> Atom (return . Just . c =<< m)

-- current node
myNode :: Par NodeId
myNode = atom $ liftCommM $ Comm.myNode

-- all nodes of the parallel machine
allNodes :: Par [NodeId]
allNodes = atom $ liftCommM $ Comm.allNodes

-- lifting an IO action into the Par monad
io :: IO a -> Par a
io = atom . liftIO

-- evaluate to weak head normal form
eval :: a -> Par a
eval x = atom (x `seq` return x)

-- force to normal form
force :: (NFData a) => a -> Par a
force x = atom (x `deepseq` return x)

-- thread creation
fork :: Par () -> Par ()
fork = atom . liftThreadM . putThread . mkThread

-- create a spark (ie. put it in the spark pool)
spark :: Closure (Par ()) -> Par ()
spark clo = atom (schedulerID >>= \ i -> liftSparkM $ putSpark i clo)

-- push a spark to the node given node (for eager execution)
pushTo :: Closure (Par ()) -> NodeId -> Par ()
pushTo clo = atom . sendPUSH clo

-- IVar creation
new :: Par (IVar a)
new = IVar <$> atom (liftIO $ newIVar)

-- write to IVar (but don't force any evaluation)
put :: IVar a -> a -> Par ()
put (IVar v) a = atom $ liftIO (putIVar v a) >>=
                        liftThreadM . putThreads

-- blocking read from IVar
get :: IVar a -> Par a
get (IVar v) = Par $ \ c -> Atom $ liftIO (getIVar v c) >>=
                                   maybe (return Nothing) (return . Just . c)

-- polling the value of an IVar; non-blocking
poll :: IVar a -> Par (Maybe a)
poll (IVar v) = atom $ liftIO (pollIVar v)

-- probing whether an IVar is full; non-blocking
probe :: IVar a -> Par Bool
probe (IVar v) = atom $ liftIO (probeIVar v)

-- globalise IVar (of Closure type)
glob :: IVar (Closure a) -> Par (GIVar (Closure a))
glob (IVar v) = GIVar <$> atom (schedulerID >>= \ i -> liftIO $ globIVar i v)

-- remote write to global IVar (of Closure type)
rput :: GIVar (Closure a) -> Closure a -> Par ()
rput gv clo = pushTo $(mkClosure [| rput_abs (gv, clo) |]) (at gv)

-- write to locally hosted global IVar; don't export
{-# INLINE rput_abs #-}
rput_abs :: (GIVar (Closure a), Closure a) -> Par ()
rput_abs (GIVar gv, clo) = atom $ schedulerID >>= \ i ->
                                  liftIO (putGIVar i gv clo) >>=
                                  liftThreadM . putThreads
